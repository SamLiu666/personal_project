**来源：[Python 异步编程入门](https://www.shiyanlou.com/courses/1278)**

# 线程进程

常见的 Linux、Windows、Mac OS 操作系统，都是支持多进程的多核操作系统。所谓多进程，就是系统可以同时运行多个任务。例如我们的电脑上运行着 QQ、浏览器、音乐播放器、影音播放器等。在操作系统中，每个任务就是一个进程。每个进程至少做一件事，多数进程会做很多事，例如影音播放器，要播放画面，同时要播放声音，在一个进程中，就有很多线程，每个线程做一件事，在一个进程中有多个线程运行就是多线程



##  线程安全

MySQL 中有 “原子操作” 的概念，打个比方：韩梅向李红转账 100 块钱，在 MySQL 中需要两步操作：韩梅账户减少 100 元，李红账户增加 100 元。如果第一步操作完成后，意外情况导致第二步没有做，李红肯定不答应，这是不允许发生的。如何保证其不发生呢？将两步操作设计成一个事务，事务里可以有多个步骤，其中任何一步出现问题，事务都将失败，前面完成的步骤全部回滚，就像什么事都没发生。这种操作就叫做原子操作，这种特性就叫做原子性。

在 Python 多线程中，变量是共享的，这也是相较多进程的一个优点，线程占用资源要少得多，但也导致多个 CPU 同时操作多个线程时会引起结果无法预测的问题，也就是说 Python 的线程不安全。

## GIL 全局解释器锁

如何解决线程安全问题？CPython 解释器使用了加锁的方法。每个进程有一把锁，启动线程先加锁，结束线程释放锁。打个比方，进程是一个厂房，厂房大门是开着的，门内有锁，工人进入大门后可以在内部上锁。厂房里面有 10 个车间对应 10 个线程，每个 CPU 就是一个工人。GIL（Global Interpreter Lock）全局锁就相当于厂房规定：工人要到车间工作，从厂房大门进去后要在里面反锁，完成工作后开锁出门，下一个工人再进门上锁。也就是说，任意时刻厂房里只能有一个工人，这样就保证了工作的安全性，这就是 GIL 的原理。当然了，GIL 的存在有很多其它益处，包括简化 CPython 解释器和大量扩展的实现。

根据上面的例子可以看出 GIL 实现了线程操作的安全性，但多线程的效率被大打折扣，一个工厂里只能有一个工人干活，很难想象。这也是 David Beazley（《Python 参考手册》和《Python Cookbook》的作者）说 “Python 线程毫无用处” 的原因。

注意，GIL 不是语言特性，而是解释器的设计特点，有些 Python 解释器例如 JPython 就没有 GIL ，除了 Python 其它语言也有 GIL 设计，例如 Ruby 。

## 多线程

实际情况并非上面讲得那么惨，Python 多线程可以成倍提高程序的运行速度，而且在多数情况下都是有效的。接着上面的例子说，一个工厂里同一时刻只能有一个工人在工作，如果这个工厂里各个车间的自动化程度极高且任务耦合度极低，工人进去只是按几下按钮，就可以等待机器完成其余工作，那情况就不一样了，这种场景下一个工人可以管理好多个车间，而且大多数时间都是等，甚至还能抽空打打羽毛球看场电影。

比如爬虫程序爬取页面数据这个场景中，CPU 做的事就是发起页面请求和处理响应数据，这两步是极快的，中间网络传输数据的过程是耗时且不占用 CPU 的。一个工人可以在吃完早饭后一分钟内快速到 1000 个车间按下发起请求的按钮，吃完午饭睡一觉，日薄西山时差不多收到网络传回的数据，又用一分钟处理数据，整个程序完成。

上面的场景中，CPU 再多也没有用处，一个 CPU 抽空就能完成整个任务了，毕竟程序中需要 CPU 做的事并不多。这就涉及到了复杂程序的分类：CPU 密集型和 IO 密集型。爬虫程序就是 IO 密集型程序。CPU 密集型程序全是手工操作，工人一刻也不能停歇，这种情况下 Python 多线程就真可以说是毫无用处了。

下面的课程中我们会经常使用 ipython 来演示，首先在终端执行 `sudo pip3 install ipython` 安装 ipython 。

### 阻塞 异步

上文的模拟爬虫示例代码中，main1 中的 for 循环运行 100 次爬取网页的操作，前一个完成后才能运行下一个，这就是同步的概念，在 crawl_url 函数内部的 IO 操作为阻塞操作，线程无法向下执行。

main2 中的第一个 for 循环，创建 100 个线程并启动，这步操作是非阻塞的，不会等一个线程运行完成才创建下一个线程，它会一气儿创建并启动 100 个线程；第二个 for 循环将主线程挂起，直到全部子线程完成，此时的主线程就是阻塞的。这种程序运行方式叫做异步，CPU 在遇到 IO 阻塞时不会站在那儿傻等，而是被操作系统派往其它线程中看看有什么事可做。

<u>所谓的异步，就是 CPU 在当前线程阻塞时可以去其它线程中工作，不管怎么设计，在一个线程内部代码都是顺序执行的，遇到 IO 都得阻塞，所谓的非阻塞，是遇到当前线程阻塞时，CPU 去其它线程工作。</u>



## 协程同步

在多线程程序中，线程切换由操作系统决定，无法人为干预。上文的模拟爬虫示例代码中各个线程间无关联，没有先后顺序，不涉及互相引用，耦合性为零，这种场景使用多线程是很适合的。**协程是在线程的基础上编写由程序员决定代码执行顺序、可以互相影响的高耦合度代码的一种高级程序设计模式。**

上文说到 “不论如何设计，在一个线程内部，代码都是顺序执行的，遇到 IO 都得阻塞” ，直到出现了协程，这句话变成了伪命题。一个线程内部可以有多个协程，相当于一个车间内部有多个子任务，一个协程遇到 IO 阻塞，CPU 会自动去另一个协程中工作，而且去哪里工作由程序自己说了算，此外连创建线程和线程切换的开销都省了，这是一个多么大的比较优势！

## 协程 生成器

生成器（或协程）有四种存在状态：

- GEN_CREATED 创建完成，等待执行
- GEN_RUNNING 解释器正在执行（这个状态在下面的示例程序中无法看到）
- GEN_SUSPENDED 在 yield 表达式处暂停
- GEN_CLOSE 执行结束，生成器停止



# asynico module

在 asyncio 模块中出现了一些新的概念，我们来认识它们：

**coroutine 协程**

协程对象，使用 asyncio.coroutine 装饰器装饰的函数被称作协程函数，它的调用不会立即执行函数，而是返回一个协程对象，即协程函数的运行结果为协程对象，注意这里说的 “运行结果” 不是 return 值。协程对象需要包装成任务注入到事件循环，由事件循环调用。

**task 任务**

将协程对象作为参数创建任务，任务是对协程对象的进一步封装，其中包含任务的各种状态。

**event_loop 事件循环**

在上一节实验中介绍线程时，将多线程比喻为工厂里的多个车间，那么协程就是一个车间内的多台机器。在线程级程序中，一台机器开始工作，车间内的其它机器不能同时工作，需要等上一台机器停止，但其它车间内的机器可以同时启动，这样就可以显著提高工作效率。在协程程序中，一个车间内的不同机器可以同时运转，启动机器、暂停运转、延时启动、停止机器等操作都可以人为设置。

事件循环能够控制任务运行流程，也就是任务的调用方。

**协程对象不能直接运行**，必须放入事件循环中或者由 yield from 语句调用。将协程对象注入事件循环的时候，其实是 run_until_complete 方法将协程包装成了一个任务（task）对象，任务对象保存了协程运行后的状态，用于未来获取协程的结果。

# 异步编程

基于 Python 生成器实现异步的模块不止 asyncio ，还有 gevent 、greenlet 等模块。